<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="兽人永不为奴" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: 'Copy',
      copy_success: 'Copied',
      copy_failure: 'Copy failed'
    },
    sidebarPadding: 40
  };
</script>

  <meta property="og:type" content="website">
<meta property="og:title" content="兽人永不为奴">
<meta property="og:url" content="http://twohappy.me/index.html">
<meta property="og:site_name" content="兽人永不为奴">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="兽人永不为奴">

<link rel="canonical" href="http://twohappy.me/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>兽人永不为奴</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">兽人永不为奴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">除非包吃包住</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/11/22/arrays-symbols-realms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/22/arrays-symbols-realms/" class="post-title-link" itemprop="url">\[译\] isArray 背后做了什么？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-22 14:21:24 / Modified: 16:26:09" itemprop="dateCreated datePublished" datetime="2019-11-22T14:21:24+08:00">2019-11-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>看到一篇文章<a href="https://jakearchibald.com/2017/arrays-symbols-realms/" target="_blank" rel="noopener">Arrays, symbols, and realms</a>，简单搜了一下，关于<a href="https://blog.xcatliu.com/2015/11/03/isarray/" target="_blank" rel="noopener">判断数组的文章</a>基本上从 <code>typeof</code>、<code>instanceof</code>、<code>Object.prototype.toString.call(obj) === &#39;[objectg Array]&#39;&#39;</code>讲到 <code>isArray</code>就完了。但是它实际上干了什么？</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在推上，一个大佬问兄弟们，<a href="https://twitter.com/awbjs/status/939240121269809152" target="_blank" rel="noopener">大家知不知道 Array.isArray(obj) 干了什么</a>，结果显示，并不知道。更重要的是，本大佬也弄错了。</p>
<h2 id="检查-arrays-的类型"><a href="#检查-arrays-的类型" class="headerlink" title="检查 arrays 的类型"></a>检查 arrays 的类型</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">假如说我们需要针对 `</span>obj<span class="string">` 是数组的情况，来专门做一些操作，比如 `</span><span class="built_in">JSON</span>.stringify<span class="string">`，它对于数组的输出，是跟其他对象不同的。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">我们可以这样：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">if</span> (obj.constructor === <span class="built_in">Array</span>) <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>但对于继承于 Array 的数据来说，就不行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpecialArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> specialArray = <span class="keyword">new</span> SpecialArray();</span><br><span class="line"><span class="built_in">console</span>.log(specialArray.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(specialArray.constructor === SpecialArray); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>针对子类我们又可以用 <code>instanceof</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(specialArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(specialArray <span class="keyword">instanceof</span> SpecialArray); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是当你遇到多个<strong><a href="https://www.ecma-international.org/ecma-262/6.0/#sec-code-realms" target="_blank" rel="noopener">领域</a></strong>的时候就不好使了：</p>
<h3 id="多个领域"><a href="#多个领域" class="headerlink" title="多个领域"></a>多个领域</h3><p>一个领域包含了 JavaScript 的全局对象，<code>self</code> 指向的那个。可以这样讲：跑在 worker 里面的代码，和跑在页面里面的代码，是属于不同领域的。iframe 之间也是这样（属于不同领域）。但是，同源的 iframe 们共享一个 ECMAScript <code>agent</code>[啥意思？]，意味着对象这个东西可以<strong>在不同领域之间传递</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe srcdoc=<span class="string">"&lt;script&gt;var arr = [];&lt;/script&gt;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = iframe.contentWindow.arr;</span><br><span class="line">  <span class="built_in">console</span>.log(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr.constructor <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>都会返回 <code>false</code>，因为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span> === iframe.contentWindow.Array); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>iframe 会有各自不同的 array 构造器…</p>
<h2 id="接下来说-Array-isArray"><a href="#接下来说-Array-isArray" class="headerlink" title="接下来说 Array.isArray"></a>接下来说 Array.isArray</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Array.isArray</code> 对在另一个领域里面创建的数组也会返回 <code>true</code>。它对<code>Array</code> 的子类也会返回 <code>true</code>，<code>JSON.stringify</code> 内部用的就是它。</p>
<p>但是，就像推上那位大佬<a href="https://twitter.com/awbjs/status/939607812094574594" target="_blank" rel="noopener">说的</a>，这不代表 <code>arr</code> 本身具有数组的方法。所有的方法们可能都被设成了 <code>undefined</code>，甚至 <code>arr</code> 的 <code>prototype</code> 可能都没了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> noProtoArray = [];</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(noProtoArray, <span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(noProtoArray.map); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(noProtoArray <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(noProtoArray)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>下面是你遇见这种数组了怎么办..</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(noProtoArray)) &#123;</span><br><span class="line">  <span class="keyword">const</span> mappedArray = <span class="built_in">Array</span>.prototype.map.call(noProtoArray, callback);</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Symbol-和-realm-（领域）"><a href="#Symbol-和-realm-（领域）" class="headerlink" title="Symbol 和 realm （领域）"></a>Symbol 和 realm （领域）</h2><p>看看这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe srcdoc=<span class="string">"&lt;script&gt;var arr = [1, 2, 3];&lt;/script&gt;"</span>&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">const</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>);</span><br><span class="line">  <span class="keyword">const</span> arr = iframe.contentWindow.arr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>地球人都知道会 log 出来 1,2,3。但这说明了啥？<br>for-of 循环内部使用的是 <code>arr[Symbol.iterator]</code>，这是跨领域之后还可以通用的。看：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="keyword">const</span> iframeWindow = iframe.contentWindow;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span> === iframeWindow.Symbol); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator === iframeWindow.Symbol.iterator); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>每个领域有它自己的 Symbol 实例的同时，他们的 <code>Symbol.iterator</code> 却是一样的。</p>
<p>引用一句<a href="https://twitter.com/Keithamus/status/939788908417748992" target="_blank" rel="noopener">话</a>，<code>Symbol</code> 同时是 JavaScript 里最特殊和最不特殊的东西了。</p>
<h3 id="最特殊"><a href="#最特殊" class="headerlink" title="最特殊"></a>最特殊</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolOne = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> symbolTwo = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(symbolOne === symbolTwo); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[symbolOne] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolTwo]); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolOne]); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<p>传给 <code>Symbol</code> 构造器的字符串只是对它的一个描述，同一个领域下面同一个描述的 symbol 也是独特的。</p>
<h3 id="最不特殊"><a href="#最不特殊" class="headerlink" title="最不特殊"></a>最不特殊</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> symbolOne = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> symbolTwo = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(symbolOne === symbolTwo); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[symbolOne] = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolTwo]); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(str)</code> 新建了一个根据你字符串唯一的 symbol 对象。重点是，跨了领域之后，它还是一样的。。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'iframe'</span>);</span><br><span class="line"><span class="keyword">const</span> iframeWindow = iframe.contentWindow;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>) === iframeWindow.Symbol.for(<span class="string">'foo'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以这个也就基本上是 <code>Symbol.iterator</code> 为啥能行的原因了。</p>
<h2 id="根据传统，自己手写个-is-函数"><a href="#根据传统，自己手写个-is-函数" class="headerlink" title="根据传统，自己手写个 is 函数"></a>根据传统，自己手写个 <code>is</code> 函数</h2><p> 那么 symbol 对象可以让我们写出跨领域能用 <code>is</code> 方法：</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> typeSymbol = <span class="built_in">Symbol</span>.for(<span class="string">'whatever-type-symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Whatever</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> isWhatever(obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; <span class="built_in">Boolean</span>(obj[typeSymbol]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[typeSymbol] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 或者下面这种不会被遍历出来</span></span><br><span class="line">  <span class="keyword">get</span> [typeSymbol]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> whatever = <span class="keyword">new</span> Whatever();</span><br><span class="line">Whatever.isWhatever(whatever); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这样唯一的一点不太好的地方，就是命名冲突了。别人也这么搞，而且还同名的话，就有问题了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/11/05/inheritance-in-javascript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/05/inheritance-in-javascript/" class="post-title-link" itemprop="url">inheritance-in-javascript</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-05 17:57:50" itemprop="dateCreated datePublished" datetime="2019-11-05T17:57:50+08:00">2019-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-22 16:14:29" itemprop="dateModified" datetime="2019-11-22T16:14:29+08:00">2019-11-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>继承这个东西都快被嚼烂了。但是没办法，不复习，还是会忘掉。</p>
<h2 id="new-的过程中发生了什么"><a href="#new-的过程中发生了什么" class="headerlink" title="new 的过程中发生了什么"></a>new 的过程中发生了什么</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age, name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.getCount = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> laowang = <span class="keyword">new</span> Person(<span class="number">32</span>, <span class="string">'laowang'</span>);</span><br><span class="line">laowang.__proto__ === Person.prototype; <span class="comment">// true</span></span><br><span class="line">laowang <span class="keyword">instanceof</span> Person; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> laozhang = &#123;&#125;;</span><br><span class="line">Person.call(laozhang, <span class="number">33</span>, <span class="string">'laozhang'</span>);</span><br><span class="line">laozhang; <span class="comment">// &#123;age: 33, name: 'laozhang'&#125;</span></span><br><span class="line">laozhang <span class="keyword">instanceof</span> Person; <span class="comment">// false</span></span><br><span class="line">laozhang.__proto__ = Person.prototype;</span><br><span class="line">laozhang <span class="keyword">instanceof</span> Person; <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p>接下来再看一段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">laowang.__proto__ === Person.prototype; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Person.prototype.__proto === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p> (摘抄一波 MDN 文档，写的太好了)  </p>
<p>当谈到继承时，JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（<code>prototype</code> ）。该原型对象也有一个自己的原型对象( <code>__proto__</code> ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。  </p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例。</p>
<h3 id="基于原型链的继承"><a href="#基于原型链的继承" class="headerlink" title="基于原型链的继承"></a>基于原型链的继承</h3><h4 id="继承属性"><a href="#继承属性" class="headerlink" title="继承属性"></a>继承属性</h4><p> JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p>
<p> <span style="background-color:##ff000088;color:#000000">注：原型链，是对象构成的链</span></p>
<p>看一段<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> f();    <span class="comment">// &#123; a: 1, b: 2 &#125;</span></span><br><span class="line"></span><br><span class="line">f.prototype.b = <span class="number">3</span>;</span><br><span class="line">f.prototype.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;a:1, b:2&#125; ---&gt; &#123;b:3, c:4&#125; ---&gt; Object.prototype---&gt; null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.a);   <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b);   <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(o.c);   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p>
<h3 id="继承方法"><a href="#继承方法" class="headerlink" title="继承方法"></a>继承方法</h3><p>JavaScript 并没有其他基于类的语言所定义的“方法”。在 JavaScript 里，任何函数都可以添加到对象上作为对象的属性。函数的继承与其他的属性继承没有差别，包括上面的“属性遮蔽”（这种情况相当于其他语言的方法重写）。</p>
<p>当继承的函数被调用时，this 指向的是当前继承的对象，而不是继承的函数所在的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  m: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o.m()); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 当调用 o.m 时，'this' 指向了 o.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line"><span class="comment">// p是一个继承自 o 的对象</span></span><br><span class="line"></span><br><span class="line">p.a = <span class="number">4</span>; <span class="comment">// 创建 p 的自身属性 'a'</span></span><br><span class="line"><span class="built_in">console</span>.log(p.m()); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 调用 p.m 时，'this' 指向了 p</span></span><br><span class="line"><span class="comment">// 又因为 p 继承了 o 的 m 函数</span></span><br><span class="line"><span class="comment">// 所以，此时的 'this.a' 即 p.a，就是 p 的自身属性 'a'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled type="checkbox"> Object.create(obj) 返回一个以 obj 为原型的对象…</li>
</ul>
<p>到现在为止，搞清楚了的是：在 JavaScript 中，一个对象如何访问到自己没有的属性/方法，通过基于原型链的继承。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ol>
<li><p>在 JavaScript 中，函数（function）是允许拥有属性的。所有的函数会有一个特别的属性 —— <code>prototype</code> 。</p>
</li>
<li><p>当试图访问一个函数 <code>someFunction</code> 的实例对象 <code>someInstance</code> 的一个属性：</p>
<ul>
<li><p>浏览器（或其他的执行环境）首先会查看 <code>someInstance</code> 中是否存在这个属性。</p>
</li>
<li><p>如果不包含这个属性，那么会在 <code>someInstance</code> 的 <code>__proto__</code> / <code>[[Prototype]]</code> / <code>constructor.prototype</code> / <code>someFunction.prototype</code>（这几个东西等价）中去查找</p>
</li>
<li><p>如果还没有，那么会在 <code>someInstance</code> 的 <code>__proto__</code> 的 <code>__proto__</code> 中查找。</p>
</li>
<li><p>（默认情况下）任何函数的原型属性都是 <code>Object.prototype</code></p>
</li>
<li><p>那么下面几个东西等价</p>
</li>
<li><p><code>someInstance.__proto__.__proto__</code></p>
</li>
<li><p><code>someFunction.prototype.__proto__</code></p>
</li>
<li><p><code>Object.prototype</code></p>
</li>
<li><p>原型链的终点是 <code>Object.prototype.__proto__</code>，它指向 <code>null</code></p>
</li>
<li><p>在 <code>__proto__</code> 的整个原型链被查看之后，这里没有更多的 <code>__proto__</code>，浏览器断定这个属性不存在，就会给出这个属性值为 <code>undefined</code> 的结论</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="拓展一下"><a href="#拓展一下" class="headerlink" title="拓展一下"></a>拓展一下</h3><ul>
<li><p>在 ES5 中引入了一个新方法 <code>Object.create(o)</code>，返回的对象的原型就是 o</p>
</li>
<li><p>在 ES6 中引入了一套关键字：<code>class</code>, <code>constructor</code>，<code>static</code>，<code>extends</code> 和 <code>super</code> 来实现 class，但实际上仍然是基于原型链的。（语法糖）</p>
</li>
<li><p>遍历对象的属性时，原型链上的<strong>每个</strong>可枚举属性都会被枚举出来。</p>
<ul>
<li>hasOwnProperty 和 Object.keys() 是 JavaScript 中两个处理属性并且不会遍历原型链的方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> property <span class="keyword">in</span> b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b.hasOwnProperty(property))&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(pro);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="再总结一下"><a href="#再总结一下" class="headerlink" title="再总结一下"></a>再总结一下</h3><ul>
<li>我们需要牢记两点：1、<strong>proto</strong>和constructor属性是对象所独有的；2、 prototype属性是函数所独有的，因为函数也是一种对象，所以函数也拥有<strong>proto</strong>和constructor属性。</li>
<li><strong>proto</strong>属性的作用就是当访问一个对象的属性时，如果该对象内部不存在这个属性，那么就会去它的<strong>proto</strong>属性所指向的那个对象里找，一直找，直到<strong>proto</strong>属性的终点null，再往上找就相当于在null上取值，会报错。通过<strong>proto</strong>属性将对象连接起来的这条链路即我们所谓的原型链。</li>
<li>prototype属性的作用就是让该函数所实例化的对象们都可以找到公用的属性和方法，即f1.<strong>proto</strong> === Foo.prototype。</li>
<li>constructor属性的含义就是指向该对象的构造函数，所有函数（此时看成对象了）最终的构造函数都指向Function。</li>
</ul>
<h3 id="再拓展一下"><a href="#再拓展一下" class="headerlink" title="再拓展一下"></a>再拓展一下</h3><ul>
<li><p>不是所有 function object 都有 prototype 属性：</p>
<blockquote>
<p>   来自<a href="https://www.ecma-international.org/ecma-262/7.0/index.html#sec-function-instances-prototype" target="_blank" rel="noopener">ECMA-262规范</a>：</p>
<p>   Function instances that can be used as a constructor have a prototype property. Whenever such a function instance is created another ordinary object is also created and is the initial value of the function’s prototype property. Unless otherwise specified, the value of the prototype property is used to initialize the [[Prototype]] internal slot of the object created when that function is invoked as a constructor.</p>
<p>   NOTE  </p>
<p>   Function objects created using Function.prototype.bind, or by evaluating a MethodDefinition (that are not a GeneratorMethod) or an ArrowFunction grammar production do not have a prototype property.</p>
</blockquote>
</li>
<li><p>可以当成构造函数用的 function，才有 prototype，用来给实例化的对象的 __proto__ 赋值。那么没打算当构造函数的，就没有了。比如：</p>
<ul>
<li><p>bind 创建的函数</p>
</li>
<li><p>很多内置函数</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.fill.prototype                 <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.prototype      <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
</li>
</ul>
</li>
<li><p>反过来对象的话，没有 __proto__ 的除了 null 还有什么？ [TDB] </p>
<ul>
<li>好像只有 Object.create(null) ？</li>
<li>Object.create(obj, { age : { value: 42, writable:true, configurable:true, enumerable:true}})</li>
</ul>
</li>
<li><p><code>__proto__</code> 是一个存在于 <code>Object.prototype</code> 上设置了 getter 和 setter 的属性。所以说法：<code>__proto__</code> 是获取 <code>[[Prototype]]</code> 的方式更 OK。其实 <code>__proto__</code> 本身不是 <code>[[Prototype]]</code>… </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype</span><br><span class="line">constructor: ƒ Object()</span><br><span class="line">hasOwnProperty: ƒ hasOwnProperty()</span><br><span class="line">isPrototypeOf: ƒ isPrototypeOf()</span><br><span class="line">propertyIsEnumerable: ƒ propertyIsEnumerable()</span><br><span class="line">toLocaleString: ƒ toLocaleString()</span><br><span class="line">toString: ƒ toString()</span><br><span class="line">valueOf: ƒ valueOf()</span><br><span class="line">__defineGetter__: ƒ __defineGetter__()</span><br><span class="line">__defineSetter__: ƒ __defineSetter__()</span><br><span class="line">__lookupGetter__: ƒ __lookupGetter__()</span><br><span class="line">__lookupSetter__: ƒ __lookupSetter__()</span><br><span class="line">get __proto__: ƒ __proto__()</span><br><span class="line">set __proto__: ƒ __proto__()</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>再去找的话，还有很多特例<ul>
<li>比如 <code>Symbol</code>，有构造函数，但是不能 new</li>
<li>比如 Generator Function，有 <code>prototype</code>，但不是构造函数</li>
<li><code>Proxy</code> [TBD] <code>BigInt</code> [TBD]</li>
</ul>
</li>
</ul>
<h1 id="20191120-补充：如何实现继承"><a href="#20191120-补充：如何实现继承" class="headerlink" title="20191120 补充：如何实现继承"></a>20191120 补充：如何实现继承</h1><h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><p>###组合继承</p>
<p>就是属性在父类构造函数中定义，方法在父类构造函数的原型上定义。</p>
<p>然后子类构造函数中 Parent.call(this,value) 来继承父类的属性</p>
<p>Child.prototype = new Parent() 来继承父类的方法</p>
<p>缺点是 new 的时候，Child 的 prototype 上面多了无用的父类属性</p>
<h3 id="组合寄生"><a href="#组合寄生" class="headerlink" title="组合寄生"></a>组合寄生</h3><p>直接用 ES5 最正确的方式来做继承<br>如此没有其它的东西，且有正确的 constructor 指向</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value: Child,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        writable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = value;</span><br><span class="line">    &#125;</span><br><span class="line">    getValue()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(value)&#123;</span><br><span class="line">        <span class="keyword">super</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/11/02/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/02/test/" class="post-title-link" itemprop="url">Untitled</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-02 17:40:35" itemprop="dateCreated datePublished" datetime="2019-11-02T17:40:35+08:00">2019-11-02</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          function click1() {
  return new Promise(function (resolve, reject) {
    const time = Math.floor(Math.random() * 3000);
    setTimeout(function () {
      resolve(`1's time is ${time}`);
    }, time);
  })
}

function click2() {
  return new Promise(function (resolve, reject) {
    const time = Math.floor(Math.random() * 3000);
    setTimeout(function () {
      resolve(`2's time is ${time}`);
    }, time);
  })
}

function userClick() {
  const count = 10;
  for (let i = 0; i < count; i++) {
    if (Math.random() > 0.5) {
      click1().then(num => console.log(num));
      console.log('click--->  1');
    } else {
      click2().then(num => console.log(num));
      console.log('click--->  2');
    }
  }
}

userClick();

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/11/01/running-electron-on-windows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/01/running-electron-on-windows/" class="post-title-link" itemprop="url">在 windows 环境下开发 Electron 应用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-11-01 13:25:41 / Modified: 19:30:24" itemprop="dateCreated datePublished" datetime="2019-11-01T13:25:41+08:00">2019-11-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在之前家里的五年旗舰<del>不如狗</del>上已经搞过一次，但是没有详细记录。导致了今天的杯具。</p>
<ul>
<li>要一步一步严格按照文档来，<a href="https://github.com/nodejs/node-gyp#installation" target="_blank" rel="noopener">installation</a></li>
<li>比如 vs 2019 在现在（2019年11月）是怎么都不行的</li>
<li>如果 vs 版本对了的话，只跟着文档安装 c++ workload，在编译时候会报错缺少一个 v140 工具集</li>
<li>我们去 vs 里面装好这个依赖</li>
<li>再次 install / install-app-deps</li>
<li>它就会自己帮你把相应的二进制文件编译好</li>
</ul>
<p>一些<strong>重要的</strong>参考链接：</p>
<p><a href="https://electronjs.org/docs/tutorial/using-native-node-modules" target="_blank" rel="noopener">https://electronjs.org/docs/tutorial/using-native-node-modules</a></p>
<p><a href="https://github.com/nodejs/node-gyp#readme" target="_blank" rel="noopener">https://github.com/nodejs/node-gyp#readme</a></p>
<p><a href="https://www.jianshu.com/p/513fc8e6f243" target="_blank" rel="noopener">https://www.jianshu.com/p/513fc8e6f243</a></p>
<p><a href="https://newsn.net/say/electron-gyp-param.html" target="_blank" rel="noopener">https://newsn.net/say/electron-gyp-param.html</a></p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node-gyp configure --module_name=node_sqlite3 --module_path=../lib/binding/electron-v7.0-win32-x64</span><br><span class="line">node-gyp rebuild --target=7.0.0 --arch=x64 --target_plathform=win32 --dist-url=https://atom.io/download/atom-shell --module_name=node_sqlite3 --module_path=../lib/binding/electron-v7.0-win-32-x64</span><br></pre></td></tr></table></figure>

<ul>
<li><code>--target</code> Electron 的版本</li>
<li><code>--arch</code> 系统架构 ia32 或者 x64</li>
<li><code>--dist-url</code> 编译头文件的地址</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/10/28/upgrade-react-native/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/28/upgrade-react-native/" class="post-title-link" itemprop="url">升级 React Native 项目</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-10-28 14:45:12 / Modified: 14:50:19" itemprop="dateCreated datePublished" datetime="2019-10-28T14:45:12+08:00">2019-10-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>升级 React Native 历来都非常痛苦，好在比起一年前，现在有了 rn-diff-purge 可以稍微减少一点 debug 的工作量。<br>我们的项目一直停留在 0.55，在今年年初的时候我开了一个分支，将它升级到了 0.58，但一直没有合并回开发分支。现在 google play 强行要求上传的 app 兼容 64 位，再次升级一波到 0.59.7。</p>
<p>后续应该会遇到很多 lib 不兼容的情况需要升级。慢慢筛查吧。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/10/24/axios-or-fetch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/24/axios-or-fetch/" class="post-title-link" itemprop="url">axios 和 fetch</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-24 15:45:20" itemprop="dateCreated datePublished" datetime="2019-10-24T15:45:20+08:00">2019-10-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-10-27 02:02:44" itemprop="dateModified" datetime="2019-10-27T02:02:44+08:00">2019-10-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>今天被问到了 fetch 的问题，一时间有点懵逼，这里整理一下。</p>
<p>首先好习惯，先上 MDN 文档：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" target="_blank" rel="noopener">Using Fetch</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" target="_blank" rel="noopener">Using XMLHttpRequest</a></li>
</ul>
<p>使用中的主要区别：</p>
<blockquote>
<p>请注意，fetch规范与jQuery.ajax()主要有两种方式的不同，牢记：  </p>
<p>当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。  </p>
<p>默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。自从2017年8月25日后，默认的credentials政策变更为same-originFirefox也在61.0b13中改变默认值</p>
</blockquote>
<p>其实还是 axios 大法好啊。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/10/17/electron-updater-wont-trigger-download-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/17/electron-updater-wont-trigger-download-events/" class="post-title-link" itemprop="url">electron-updater 检测到新版本后，不会触发下载事件</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-10-17 09:32:50 / Modified: 09:43:26" itemprop="dateCreated datePublished" datetime="2019-10-17T09:32:50+08:00">2019-10-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>公司 Electron 项目因为 custom 了自动升级之后的动作，所以需要获取 autoUpdater 的下载进度事件，来确定下载完成。</p>
<p>最近总是有个莫名其妙的问题，在测试环境下，偶尔会正常弹出应该弹出来的对话框，其他时候不管怎么样都不会触发下载事件。但手动重启应用，版本又确实升级了。。</p>
<p>搞了一晚上的结果：</p>
<ul>
<li>electron-updater 的下载缓存位于 <code>~/Library/Application Support/Caches/你的应用-updater/</code> 下面</li>
<li>当已从低版本向某个特定的高版本升级过，缓存中存在这个版本的升级包（macOS 默认为 <code>zip</code>），下一次再次向这个版本升级时候，就不会再次进行下载</li>
<li><code>download-progress</code> 不会触发</li>
<li>似乎 <code>update-downloaded</code> 会触发，待验证</li>
</ul>
<p>临时的 workaround 就是删一波缓存就行了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/10/13/what-is-a-side-effect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/13/what-is-a-side-effect/" class="post-title-link" itemprop="url">what-is-a-side-effect</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-13 12:59:19" itemprop="dateCreated datePublished" datetime="2019-10-13T12:59:19+08:00">2019-10-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 12:59:53" itemprop="dateModified" datetime="2019-11-02T12:59:53+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>“Side Effect” is not a react-specific term. It is a general concept about behaviours of functions. A function is said to have side effect if it trys to modify anything outside its body. For example, if it modidifies a global variable, then it is a side effect. If it makes a network call, it is a side effect as well.<br><a href="https://www.reddit.com/r/reactjs/comments/8avfej/what_does_side_effects_mean_in_react/" target="_blank" rel="noopener">source</a></p>
<p>A “side effect” is anything that affects something outside the scope of the function being executed. These can be, say, a network request, which has your code communicating with a third party (and thus making the request, causing logs to be recorded, caches to be saved or updated, all sorts of effects that are outside the function.</p>
<p>There are more subtle side effects, too. Changing the value of a closure-scoped variable is a side effect. Pushing a new item onto an array that was passed in as an argument is a side effect. Functions that execute without side effects are called “pure” functions: they take in arguments, and they return values. Nothing else happens upon executing the function. This makes the easy to test, simple to reason about, and functions that meet this description have all sorts of useful properties when it comes to optimization or refactoring.</p>
<p>Pure functions are deterministic (meaning that, given an input, they always return the same output), but that doesn’t mean that all impure functions have side effects. Generating a random value within a function makes it impure, but isn’t a side effect, for example. React is all about pure functions, and asks that you keep several lifecycle methods pure, so these are good questions to be asking.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2019/09/27/react-native-target-sdk-version-28/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/27/react-native-target-sdk-version-28/" class="post-title-link" itemprop="url">google play 要求 targetSdkVersion >= 28</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-27 11:03:49" itemprop="dateCreated datePublished" datetime="2019-09-27T11:03:49+08:00">2019-09-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-28 01:08:19" itemprop="dateModified" datetime="2019-09-28T01:08:19+08:00">2019-09-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近给项目升级sdk版本：</p>
<p>compileSdkVersion：26 -&gt; 28</p>
<p>targetSdkVersion：23 -&gt; 28</p>
<p>buildToolsVersion：”25.0.2” -&gt; “28.0.3”</p>
<p>support包：”24.2.1” -&gt; “28.0.0”</p>
<p>遇到一些问题，在此记录一下解决办法：</p>
<p>一、编译报错：junit.framework.Assert不存在<br>项目中有个地方用到了Assert类（使用Assert.assertTrue()），原本的导包是：</p>
<p>import junit.framework.Assert;<br>但编译时报错：junit.framework.Assert不存在。</p>
<p>原因：Assert类在新版本中从junit.framework中移除，移到org.junit中。</p>
<p>解决办法：</p>
<p>(1)、找到Androidstudio目录，将.\gradle\gradle-4.4\lib\plugins目录下的junit-4.12jar，拷贝到工程app目录下的libs文件夹中，并引入，即在build.gradle中添加一行：compile files(“libs/junit-4.12.jar”)，如：</p>
<p>dependencies {<br>    …<br>    compile files(‘libs/junit-4.12.jar’)<br>}<br>(2)、将导包 import junit.framework.Assert 替换为 org.junit.Assert;</p>
<p>二、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FAILURE: Build failed with an exception.</span><br><span class="line"></span><br><span class="line">* What went wrong:</span><br><span class="line">Execution failed for task &apos;:app:lintVitalRelease&apos;.</span><br><span class="line">&gt; Could not resolve all files for configuration &apos;:app:lintClassPath&apos;.</span><br><span class="line">   &gt; Could not resolve org.jvnet.staxex:stax-ex:1.7.7.</span><br><span class="line">     Required by:</span><br><span class="line">         project :app &gt; com.android.tools.lint:lint-gradle:26.2.1 &gt; com.android.tools:sdk-common:26.2.1 &gt; com.android.tools:sdklib:26.2.1 &gt; com.android.tools:repository:26.2.1 &gt; org.glassfish.jaxb:jaxb-runtime:2.2.11</span><br><span class="line">      &gt; Could not resolve org.jvnet.staxex:stax-ex:1.7.7.</span><br><span class="line">         &gt; Could not get resource &apos;https://jitpack.io/org/jvnet/staxex/stax-ex/1.7.7/stax-ex-1.7.7.jar&apos;.</span><br><span class="line">            &gt; Could not HEAD &apos;https://jitpack.io/org/jvnet/staxex/stax-ex/1.7.7/stax-ex-1.7.7.jar&apos;. Received status code 522 from server: Origin Connection Time-out</span><br><span class="line">   &gt; Could not resolve com.sun.xml.fastinfoset:FastInfoset:1.2.13.</span><br><span class="line">     Required by:</span><br><span class="line">         project :app &gt; com.android.tools.lint:lint-gradle:26.2.1 &gt; com.android.tools:sdk-common:26.2.1 &gt; com.android.tools:sdklib:26.2.1 &gt; com.android.tools:repository:26.2.1 &gt; org.glassfish.jaxb:jaxb-runtime:2.2.11</span><br><span class="line">      &gt; Could not resolve com.sun.xml.fastinfoset:FastInfoset:1.2.13.</span><br><span class="line">         &gt; Could not get resource &apos;https://jitpack.io/com/sun/xml/fastinfoset/FastInfoset/1.2.13/FastInfoset-1.2.13.jar&apos;.</span><br><span class="line">            &gt; Could not HEAD &apos;https://jitpack.io/com/sun/xml/fastinfoset/FastInfoset/1.2.13/FastInfoset-1.2.13.jar&apos;. Received status code 522 from server: Origin Connection Time-out</span><br></pre></td></tr></table></figure>

<p>解决方式：<a href="https://github.com/jitpack/jitpack.io/issues/3973#issuecomment-531199645" target="_blank" rel="noopener">issue</a></p>
<p>加上 <code>www</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maven &#123; url &quot;https://www.jitpack.io&quot; &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>项目内签名（命令行打包需要）<br><a href="https://github.com/facebook/react-native/issues/16854" target="_blank" rel="noopener">https://github.com/facebook/react-native/issues/16854</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/12/03/console/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/12/03/console/" class="post-title-link" itemprop="url">「旧笔记搬运」 关于 console</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-12-03 12:45:55" itemprop="dateCreated datePublished" datetime="2017-12-03T12:45:55+08:00">2017-12-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 12:47:13" itemprop="dateModified" datetime="2019-11-02T12:47:13+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>当使用JavaScript编写网页代码时，有很多API可以使用。</p>
</blockquote>
<p>日常编写代码的过程中，我们已经见过很多诸如 <strong>Document</strong>、<strong>Window</strong> 这样通用的对象，本文将介绍同样司空见惯的 <strong>Console</strong> 对象的几个不常见的用法。</p>
<p>全部的 Web API 接口可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API" target="_blank" rel="noopener">这里</a> 查看。<br>Console对象的全部接口可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Console" target="_blank" rel="noopener">这里</a> 查看。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>console 对象提供对浏览器控制台的接入。不同浏览器上它的工作方式是不一样的，但这里会介绍一些大都会提供的接口特性。<br>Console对象可以在任何全局对象中访问，它被浏览器定义为 Window.console，也可被简单的 console 调用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"some coolcode message!"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>常用的 <strong>console.log()</strong> 这里就不赘述了。当我们需要对某些比较长的对象数组进行调试，console.log可能就不那么直观，这里就是 console.table 起作用的地方了。</p>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>可以将数据以表格的形式显示。</p>
<p>这个方法接收一个强制的参数，它必须是一个数组或者是一个对象，还可以接受一个额外的参数描述表格的列数。</p>
<p>它把数据以table的形式打印出来， 在数组中的每一个元素（或对象中可枚举的属性）将会以行的形式显示在table中。</p>
<p>table的第一列是index。如果数据是一个数组，那么值就是索引。 如果数据是一个对象，那么它的值就是属性名称。 console.table 具体能展示的数据长度根据浏览器有所不同，不过一般来讲够用了。</p>
<h4 id="几个例子，请自行在-console-中尝试"><a href="#几个例子，请自行在-console-中尝试" class="headerlink" title="几个例子，请自行在 console 中尝试"></a>几个例子，请自行在 console 中尝试</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印一个由字符串组成的数组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table([<span class="string">"apples"</span>, <span class="string">"oranges"</span>, <span class="string">"bananas"</span>]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印一个属性值是字符串的对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> me = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(me);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元数组的打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people = [[<span class="string">"John"</span>, <span class="string">"Smith"</span>], [<span class="string">"Jane"</span>, <span class="string">"Doe"</span>], [<span class="string">"Emily"</span>, <span class="string">"Jones"</span>]]</span><br><span class="line"><span class="built_in">console</span>.table(people);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印一个包含对象的数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="string">"Doe"</span>);</span><br><span class="line"><span class="keyword">var</span> emily = <span class="keyword">new</span> Person(<span class="string">"Emily"</span>, <span class="string">"Jones"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table([john, jane, emily]);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印属性名是对象的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> family = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">family.mother = <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">family.father = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line">family.daughter = <span class="keyword">new</span> Person(<span class="string">"Emily"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(family);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个对象数组，只打印 firstName</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> john = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Smith"</span>);</span><br><span class="line"><span class="keyword">var</span> jane = <span class="keyword">new</span> Person(<span class="string">"Jane"</span>, <span class="string">"Doe"</span>);</span><br><span class="line"><span class="keyword">var</span> emily = <span class="keyword">new</span> Person(<span class="string">"Emily"</span>, <span class="string">"Jones"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table([john, jane, emily], [<span class="string">"firstName"</span>]);</span><br></pre></td></tr></table></figure>

<p><strong>注意：可以点击每一列的第一行（表头），来对输出的表进行排序</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/11/13/about-fractal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/13/about-fractal/" class="post-title-link" itemprop="url">「旧笔记搬运」关于 fractal</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-11-13 12:47:36" itemprop="dateCreated datePublished" datetime="2017-11-13T12:47:36+08:00">2017-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 12:48:28" itemprop="dateModified" datetime="2019-11-02T12:48:28+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一句话介绍"><a href="#一句话介绍" class="headerlink" title="一句话介绍"></a>一句话介绍</h2><blockquote>
<p><a href="https://fractal.thephpleague.com/" target="_blank" rel="noopener">Fractal</a> output complex, flexible, ajax/restful data structures  </p>
</blockquote>
<p>Fractal 为复杂的数据输出提供了样式和转化层。</p>
<h2 id="最简单的例子"><a href="#最简单的例子" class="headerlink" title="最简单的例子"></a>最简单的例子</h2><p>正常情况下，下面的代码是分散在项目的各处的</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">Manager</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">Resource</span>\<span class="title">Collection</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Manager 实例</span></span><br><span class="line">$fractal = <span class="keyword">new</span> Manager();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从某个地方获取到需要的数据，比如说 User::all()</span></span><br><span class="line">$books = [</span><br><span class="line">	[</span><br><span class="line">		<span class="string">'id'</span> =&gt; <span class="string">'1'</span>,</span><br><span class="line">		<span class="string">'title'</span> =&gt; <span class="string">'Hogfather'</span>,</span><br><span class="line">		<span class="string">'yr'</span> =&gt; <span class="string">'1998'</span>,</span><br><span class="line">		<span class="string">'author_name'</span> =&gt; <span class="string">'Philip K Dick'</span>,</span><br><span class="line">		<span class="string">'author_email'</span> =&gt; <span class="string">'philip@example.org'</span>,</span><br><span class="line">	],</span><br><span class="line">	[</span><br><span class="line">		<span class="string">'id'</span> =&gt; <span class="string">'2'</span>,</span><br><span class="line">		<span class="string">'title'</span> =&gt; <span class="string">'Game Of Kill Everyone'</span>,</span><br><span class="line">		<span class="string">'yr'</span> =&gt; <span class="string">'2014'</span>,</span><br><span class="line">		<span class="string">'author_name'</span> =&gt; <span class="string">'George R. R. Satan'</span>,</span><br><span class="line">		<span class="string">'author_email'</span> =&gt; <span class="string">'george@example.org'</span>,</span><br><span class="line">	]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把得到的数据，传给一个 Collection。一起传入的还有一个 Transformer，可以是一个回调函数或者一个 Transformer 对象。</span></span><br><span class="line">$resource = <span class="keyword">new</span> Collection($books, <span class="function"><span class="keyword">function</span><span class="params">(array $book)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        <span class="string">'id'</span>      =&gt; (int) $book[<span class="string">'id'</span>],</span><br><span class="line">        <span class="string">'title'</span>   =&gt; $book[<span class="string">'title'</span>],</span><br><span class="line">        <span class="string">'year'</span>    =&gt; (int) $book[<span class="string">'yr'</span>],</span><br><span class="line">        <span class="string">'author'</span>  =&gt; [</span><br><span class="line">        	<span class="string">'name'</span>  =&gt; $book[<span class="string">'author_name'</span>],</span><br><span class="line">        	<span class="string">'email'</span> =&gt; $book[<span class="string">'author_email'</span>],</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">'links'</span>   =&gt; [</span><br><span class="line">            [</span><br><span class="line">                <span class="string">'rel'</span> =&gt; <span class="string">'self'</span>,</span><br><span class="line">                <span class="string">'uri'</span> =&gt; <span class="string">'/books/'</span>.$book[<span class="string">'id'</span>],</span><br><span class="line">            ]</span><br><span class="line">        ]</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后用 Manager 实例来转化数据</span></span><br><span class="line">$array = $fractal-&gt;createData($resource)-&gt;toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Turn all of that into a JSON string</span></span><br><span class="line"><span class="keyword">echo</span> $fractal-&gt;createData($resource)-&gt;toJson();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: &#123;"data":[&#123;"id":1,"title":"Hogfather","year":1998,"author":&#123;"name":"Philip K Dick","email":"philip@example.org"&#125;&#125;,&#123;"id":2,"title":"Game Of Kill Everyone","year":2014,"author":&#123;"name":"George R. R. Satan","email":"george@example.org"&#125;&#125;]&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h2><h3 id="Resources-资源"><a href="#Resources-资源" class="headerlink" title="Resources 资源"></a>Resources 资源</h3><p><strong>Resource</strong> 是一个对象，代表了数据，并且知道数据对应的“转化器”是什么。<br>有两种 <strong>Resources</strong>：</p>
<ol>
<li>League\Fractal\Resource\Item - 单个资源</li>
<li>League\Fractal\Resource\Collection - 资源的集合<br>它们的构造函数接受实际操作的“数据”作为第一个参数，接受“转化器”作为第二个参数。</li>
</ol>
<h3 id="Serializers-序列化器"><a href="#Serializers-序列化器" class="headerlink" title="Serializers 序列化器"></a>Serializers 序列化器</h3><p>一个序列化器会以某种方式组织你的<strong>转化过的</strong>数据。Fractal 提供了 <strong>DataArraySerializer</strong>、<strong>ArraySerializer</strong> 和 <strong>JsonApiSerializer</strong>，也可以自己来写。<br>比较常用的是 <strong>DataArraySerializer</strong>，但是它会给数据增加一个 <strong>data</strong> 的命名空间，如果不喜欢，可以使用其他类型，或者自己实现一个。</p>
<h3 id="Transformers-转化器"><a href="#Transformers-转化器" class="headerlink" title="Transformers 转化器"></a>Transformers 转化器</h3><p>这个是最常用的一个内容。</p>
<h4 id="转化器类"><a href="#转化器类" class="headerlink" title="转化器类"></a>转化器类</h4><p>必须继承 <strong>League\Fractal\TransformerAbstract</strong>，并且包含一个 <strong>transform()</strong> 方法。这个方法相当于转化的格式，具体可以参考上面例子里面的回调函数。</p>
<h4 id="Including-Data-包含数据"><a href="#Including-Data-包含数据" class="headerlink" title="Including Data 包含数据"></a>Including Data 包含数据</h4><p>比如我们的 Book 模型是有一些关系的，比如说 作者 Author，出版社 Press。<br>在模型里我们定义好相关的关系之后，在转化器类里面可以这样来包含相关的（转化好的）数据。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Transformer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Acme</span>\<span class="title">Model</span>\<span class="title">Book</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>\<span class="title">TransformerAbstract</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookTransformer</span> <span class="keyword">extends</span> <span class="title">TransformerAbstract</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $defaultIncludes = [</span><br><span class="line">        <span class="string">'author'</span></span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> $availableIncludes = [</span><br><span class="line">        <span class="string">'author'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">transform</span><span class="params">(Book $book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">'id'</span>    =&gt; (int) $book-&gt;id,</span><br><span class="line">            <span class="string">'title'</span> =&gt; $book-&gt;title,</span><br><span class="line">            <span class="string">'year'</span>    =&gt; (int) $book-&gt;yr,</span><br><span class="line">            <span class="string">'links'</span>   =&gt; [</span><br><span class="line">                [</span><br><span class="line">                    <span class="string">'rel'</span> =&gt; <span class="string">'self'</span>,</span><br><span class="line">                    <span class="string">'uri'</span> =&gt; <span class="string">'/books/'</span>.$book-&gt;id,</span><br><span class="line">                ]</span><br><span class="line">            ],</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">includeAuthor</span><span class="params">(Book $book)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $author = $book-&gt;author;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;item($author, <span class="keyword">new</span> AuthorTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>里面有两种包含，默认的总是会自动获取对应关系的数据，比如 user 的返回数据里面会给每一个 user 带上对应的 user_info。<br>可用的包含则必须要调用 <strong>parseIncludes</strong> 方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">use</span> <span class="title">League</span>\<span class="title">Fractal</span>;</span><br><span class="line"></span><br><span class="line">$fractal = <span class="keyword">new</span> Fractal\Manager();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'include'</span>])) &#123;</span><br><span class="line">    $fractal-&gt;parseIncludes($_GET[<span class="string">'include'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>否则不会生效。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/11/04/about-css-positioning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/04/about-css-positioning/" class="post-title-link" itemprop="url">「旧笔记搬运」关于 Css 定位</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-11-04 12:47:36" itemprop="dateCreated datePublished" datetime="2017-11-04T12:47:36+08:00">2017-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 12:51:23" itemprop="dateModified" datetime="2019-11-02T12:51:23+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 CSS 中，最基本的布局任务，一般是通过浮动和定位来完成。在对<em>选择器</em>，<em>结构和层叠</em>，<em>值和单位</em>，<em>字体</em>，<em>文本属性</em>，<em>基本视觉格式化</em>，<em>内外边距、边框</em>，<em>颜色和背景</em>，这一些点有所了解之后，我们会遇到对页面的结构进行调整的需求，比如列式布局，布局的一部分与另一部分重叠这样的要求。本文接下来就要介绍这些基本的工具。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>定位的原理很简单，利用定位，可以准确地定义元素框<strong>相对于</strong>其<strong>正常位置</strong>应该出现在哪里，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="定位的类型"><a href="#定位的类型" class="headerlink" title="定位的类型"></a>定位的类型</h4><p>通过使用 position 属性，可以选择 4 种不同类型的定位，这会影响元素框生成的方式：</p>
<ul>
<li><code>static</code> ：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。</li>
<li><code>relative</code> ：元素框偏移某个距离。元素仍保持其未定位前的形状，它原本所占的空间仍保留。</li>
<li><code>absolute</code>：元素框从文档流完全删除，并相对于其<strong>包含块</strong>定位，包含块可能是文档中的另外一个元素，或者是初始包含块。元素原来在正常文档流中所占的空间会关闭，就好像该元素原来不存在一样。元素定位后生成一个<strong>*块级框</strong>，而不论原来它在正常流中生成的是什么类型的框。 </li>
<li><code>fixed</code>：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身（浏览器窗口）。</li>
</ul>
<h4 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h4><p>CSS2.1 对定位元素的包含块，定义了以下的行为：</p>
<ul>
<li>“根元素”的包含块，由用户代理建立，在 HTML 中，根元素就是 html 元素。</li>
<li>对于一个非根元素，如果其 position 值是 relative 或 static，包含块则由最近的块级框、表单元格或行内块祖先框的内容边界构成。</li>
<li>对于一个非根元素，如果其 position 值是 absolute，包含块设置为最近的 position 值不是 static 的祖先元素，这个过程如下：<ul>
<li>如果这个祖先是块级元素，包含块则设置为该元素的内边距边界；也就是由边框界定的区域。</li>
<li>如果这个祖先是行内元素，包含块则设置为该祖先元素的内容边界。在从左向右读的语言中，包含块的上边界和左边界是该祖先元素中<strong>*第一个框</strong>内容区的上边界和左边界，包含块的下边界和右边界是<strong>最后一个框</strong>内容区的下边界和右边界。</li>
<li>如果没有祖先，元素的包含块定义为初始包含块。</li>
</ul>
</li>
</ul>
<h4 id="偏移属性"><a href="#偏移属性" class="headerlink" title="偏移属性"></a>偏移属性</h4><p>也就是常见的 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>。（这里说一下，css 中“上下左右”的顺序，一般都是 “上右下左”，顺时针这么一个圈。）<br>这些属性，描述的是<strong>距离包含块最近边的偏移</strong>。例如，<code>top</code> 描述了定位元素上外边距边界距离其包含块的顶端有多远。top 为正值，会把定位元素的上外边距下移，若为负值，则会把定位元素的上外边距移到其包含块的顶端之上。</p>
<h3 id="宽度和高度"><a href="#宽度和高度" class="headerlink" title="宽度和高度"></a>宽度和高度</h3><h4 id="设置宽度和高度"><a href="#设置宽度和高度" class="headerlink" title="设置宽度和高度"></a>设置宽度和高度</h4><p>对于定位元素，如果使用 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 来描述4个边的放置位置，那么它的高度和宽度将由这些偏移隐含确定。</p>
<p data-height="265" data-theme-id="0" data-slug-hash="XzdRJR" data-default-tab="result" data-user="twohappy" data-embed-version="2" data-pen-title="position-example-1" class="codepen">See the Pen <a href="https://codepen.io/twohappy/pen/XzdRJR/" target="_blank" rel="noopener">position-example-1</a> by twohappy (<a href="https://codepen.io/twohappy" target="_blank" rel="noopener">@twohappy</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<h4 id="限制宽度和高度"><a href="#限制宽度和高度" class="headerlink" title="限制宽度和高度"></a>限制宽度和高度</h4><p>如果有必要，可以通过 <code>min-width</code>、<code>min-height</code>、<code>max-width</code>、 <code>max-height</code> 来限制元素的尺寸。</p>
<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><h4 id="包含块和绝对定位元素"><a href="#包含块和绝对定位元素" class="headerlink" title="包含块和绝对定位元素"></a>包含块和绝对定位元素</h4><p>元素绝对定位时，其包含块是最近的 position 值不为 static 的祖先元素。通常可以人为指定一个元素作为这个包含块，将其 position 指定为 relative，且没有偏移值。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.contain</span> &#123;<span class="attribute">position</span>: relative;&#125;</span><br></pre></td></tr></table></figure>

<p>简单的例子：</p>
<p data-height="265" data-theme-id="0" data-slug-hash="VraWMv" data-default-tab="result" data-user="twohappy" data-embed-version="2" data-pen-title="position-absolute-eg.2" class="codepen">See the Pen <a href="https://codepen.io/twohappy/pen/VraWMv/" target="_blank" rel="noopener">position-absolute-eg.2</a> by twohappy (<a href="https://codepen.io/twohappy" target="_blank" rel="noopener">@twohappy</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<p>有一点：元素绝对定位时，还会为其后代元素建立一个包含块，绝对定位的元素 E，它的子元素 C 如果也是绝对定位的，C 的偏移量是相对于 E 的。</p>
<h4 id="绝对定位元素的放置和大小"><a href="#绝对定位元素的放置和大小" class="headerlink" title="绝对定位元素的放置和大小"></a>绝对定位元素的放置和大小</h4><p>“放置” 和 “大小” 在绝对定位元素身上，是紧密联系着的两个概念。如前文提到的，对于定位元素，如果使用 <code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code> 来描述4个边的放置位置，那么它的高度和宽度将由这些偏移隐含确定。<br>但是如果这样之后，再设置一个显式的高度和宽度，会怎么样呢？会有冲突，必须将某些冲突的值忽略掉。</p>
<h4 id="自动边偏移"><a href="#自动边偏移" class="headerlink" title="自动边偏移"></a>自动边偏移</h4><p>元素绝对定位时，如果除 bottom 外，某个任意偏移属性设置为 auto，会有一种特殊行为。</p>
<p data-height="265" data-theme-id="0" data-slug-hash="gXrRdW" data-default-tab="result" data-user="twohappy" data-embed-version="2" data-pen-title="absolute-position eg.2" class="codepen">See the Pen <a href="https://codepen.io/twohappy/pen/gXrRdW/" target="_blank" rel="noopener">absolute-position eg.2</a> by twohappy (<a href="https://codepen.io/twohappy" target="_blank" rel="noopener">@twohappy</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<p>绝对定位元素没有对任何方向上的偏移值进行约束时，会出现在它的“静态位置”，就是 position 是 static 时，出现的位置。</p>
<h4 id="非替换元素的放置和大小"><a href="#非替换元素的放置和大小" class="headerlink" title="非替换元素的放置和大小"></a>非替换元素的放置和大小</h4><p data-height="265" data-theme-id="0" data-slug-hash="PONjVJ" data-default-tab="result" data-user="twohappy" data-embed-version="2" data-pen-title="过度受限下的绝对定位元素" class="codepen">See the Pen <a href="https://codepen.io/twohappy/pen/PONjVJ/" target="_blank" rel="noopener">过度受限下的绝对定位元素</a> by twohappy (<a href="https://codepen.io/twohappy" target="_blank" rel="noopener">@twohappy</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
这里提出一个词叫做“过度受限”，比如一个很大的包含块的绝对定位子元素，左右偏移都限制为10px，左右外边距也都限制为10px，本身宽度也设置为10px，这时 `right`，右偏移会失效，并重置成 auto。
如果某一个横向的外边距被设置成 auto，那么只要剩下的限制条件可以满足公式，就都会生效。具体请看例子。

<p>垂直方向的行为，基本和水平方向上一致，只不过忽略的属性从 right，变成了 bottom。</p>
<h4 id="替换元素的放置和大小"><a href="#替换元素的放置和大小" class="headerlink" title="替换元素的放置和大小"></a>替换元素的放置和大小</h4><p>替换元素有固有的高度和宽度，所以较容易确定，再这里不多赘述。</p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>固定定位除了包含块为视窗之外，其它行为和绝对定位很类似：</p>
<ol>
<li>过度受限时，忽略 right 、 bottom 。</li>
<li>偏移量未设置时，出现在它的静态位置。</li>
</ol>
<p>这里有一个点：针对一个特定的需求，相对于父元素的固定定位。如果有一个可以滚动的内容区域，需要相对于这个区域，显示一个固定的小块内容，不随内容滚动而滚动，可以这样写：</p>
<p data-height="265" data-theme-id="0" data-slug-hash="aVNybO" data-default-tab="result" data-user="twohappy" data-embed-version="2" data-pen-title="相对父元素fixed定位" class="codepen">See the Pen <a href="https://codepen.io/twohappy/pen/aVNybO/" target="_blank" rel="noopener">相对父元素fixed定位</a> by twohappy (<a href="https://codepen.io/twohappy" target="_blank" rel="noopener">@twohappy</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>这个也很好理解，因为元素不会从文档流中删除，原来的位置仍然保留，只是将内容偏移一定的距离。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/11/04/red-braised-pork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/11/04/red-braised-pork/" class="post-title-link" itemprop="url">「旧笔记搬运」关于红烧肉</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-11-04 12:47:36" itemprop="dateCreated datePublished" datetime="2017-11-04T12:47:36+08:00">2017-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 12:57:26" itemprop="dateModified" datetime="2019-11-02T12:57:26+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1）五花肉：500克。以前看到有人说，红烧肉必须一做就做一大锅，没有两三斤肉烧不出好吃的红烧肉。其实并非如此。对于小家庭来说，500克算是一个比较合适的量，一次做得太多，虽然吃的时候过瘾，过后肯定后悔。倒不如每次都保留一个良好的印象，每过一段时间就做一顿解解馋，这更加符合健康之道。</p>
<p>五花肉的层次越多越好，我比较偏好猪肋骨外侧的“上五花”，跟猪腹部的五花肉相比，这个部位脂肪层次多，但是每层脂肪又比较薄。这些五花肉需要提前切成3－4厘米见方的小块，肉块过小，瘦肉容易变硬变干，肉块过大，烹调过程中内部油脂不容易渗出，难免有些油腻。</p>
<p>2）老抽酱油：20克</p>
<p>2）料酒：20克</p>
<p>3）干红辣椒：1支</p>
<p>4）桂皮：一段（大概1厘米长就可以了，不要使用桂皮粉，烹调过程中会变黑，影响菜的品相）</p>
<p>5）生姜：2－3厘米见方，切成片</p>
<p>6）小葱：25克，切成5－6厘米的长段</p>
<p>7）糖：30克</p>
<p>8）盐：半茶匙（约3－4克）</p>
<p>9）八角：4－5朵</p>
<p>10）花生油：10克<br>一步是准备配料，一旦开启炉灶，红烧肉最好一气呵成，中间任何不必要的停顿都会影响菜的口味，所以必须提前把所有材料准备停当。</p>
<p>第二步需要对五花肉进行预处理，传统上至少有三种处理方式：油炸、焯水和煸炒。除此之外，还可以借鉴西餐里面处理肉类的办法，直接把五花肉放在大火预热90秒的平底锅里面煎。</p>
<p>把五花肉的四个侧面（不要去煎顶面的猪皮和底面的瘦肉层）都煎成金黄色，经过这样处理，一方面可以除去肥肉中的一部分油脂，猪肉表面金黄色的薄层会在慢炖的过程中融化在汤汁里面，增加许多风味，如果你不信，现在就可以把鼻子凑在煎好的五花肉上闻一闻，是不是已经香气扑鼻了呢？</p>
<p>煎的过程中可以使用不粘锅，翻动五花肉的时候尽量使用硅胶夹子，动作要轻柔，这样可以保护肉的形态。煎好的五花肉放在盘子里面盖上铝箔保温备用。</p>
<p>第三步是炒糖色。红烧肉的“红”其实就是焦糖的颜色。糖加热到170摄氏度的时候就会转化成焦糖，红烧菜肴最后收汁的时候，汤汁里面的糖在高温的作用下就会变成焦糖，给菜肴覆盖一层诱人的红棕色，并增添许多风味。理论上说，炒糖色并非绝对必须，可以在最后收汁的时候完成这个过程。但是红烧肉必须用加水（或者酒），收汁的时候把这些水完全烧干需要不少时间，等待过程当中，瘦肉部分可能就会变干变硬。提前炒好糖色就可以避免这些麻烦。</p>
<p>炒糖色最好就用炖肉的锅子，这样等会就可以直接把肉和糖混合在一起。炖肉锅子的选择非常重要，直接关系到红烧肉的品质。如果你做的红烧肉瘦肉部分有变干变硬的倾向，十有八九就是锅子没有选对。选择锅子的时候首先要考虑的是锅盖的密封性，锅盖上绝对不能有通气孔，锅盖和锅的配合必须严丝合缝。本来我们也没有注意到这个问题，LG用锅子烧米饭的时候发现，但凡那些锅盖上有通气孔的锅子，煮出来的米饭表层都是硬的，而那些锅盖密封性能很好的锅子，煮出来的米饭表层和内层都是软的。由此联想到红烧肉的问题，LG后来通过对照试验就验证了这个猜测。其次锅底导热的均匀性也非常重要，局部过热很容易让富含胶质的红烧肉粘在锅底。人们常常觉得砂锅导热比较均匀，其实并不准确，砂锅因为导热系数低，锅底的受热其实很不均匀。个人推荐使用不锈钢复底锅，其导热均匀性比厚底铸铁锅还要好。</p>
<p>在锅子里面倒入10克花生油，然后倒入30克白糖。花生油在这里就是起到一个导热媒介的作用，就像电脑CPU和风扇之间的导热硅脂一样，可以加快糖融化的过程。</p>
<p>很快就会变成金黄色，这个时候你就需要把炉灶火力降到最低，或者干脆把锅子从炉灶上移开，因为焦糖变色的过程非常迅速，就是短短几秒钟的事情。拍摄过程中，LG就是因为等我聚焦，结果锅子在炉灶上停留的时间稍长了一点，炒好的糖色迅速变成深红色，进而变成黑色，LG只好倒掉重新再来。</p>
<p>然后把前面煎好的五花肉放进锅子里面，翻动一下，让糖色均匀地裹在肉的表面。注意不要把所有的肉一起倒进锅子里面，因为里面析出的汁水跟滚烫的糖混合后会飞溅出来，比较安全的办法就是用夹子把肉一块块放进锅子里面，翻动的时候动作要轻柔，一来是保护五花肉的形态，二来是避免滚烫的汁水飞溅出来。</p>
<p>第四步就是慢火炖肉。在锅子里面放入切好的葱段、姜片、八角、桂皮和20克老抽酱油，翻动一下，让配料和五花肉混合均匀。</p>
<p>然后加入20克料酒和1支干红辣椒，翻炒均匀。</p>
<p>最后倒入沸水，倒水的时候要贴着锅边，不要直接把水浇在肉上面，否则前面辛辛苦苦刚给五花肉裹上的糖色就被热水冲掉了。</p>
<p>水的高度以能够淹没肉的高度的3/4为准，然后加入半茶匙盐（3－4克），翻动一下，让盐溶解在汤汁里面。对于红烧肉来说，就像苏东坡说的那样，应该少放水，但是这样一来就有一些肉直接暴露在水面上，如果锅盖密封性能比较好，这些暴露在外的肉就能保持较多的水分，如果锅盖密封性能不好，肉里的汁水就会渐渐蒸发，进而变干变硬。</p>
<p>火烧开后，立刻把火力降到最低（把锅子转移到最小的灶眼上面，用最小的火力），慢火炖上90分钟左右。</p>
<p>第五步是收汁。把锅子里面的汁水倒出来，倒的过程中用滤篮滤去八角桂皮等香料，五花肉仍然留在锅子里面，盖紧锅盖放在一边备用。</p>
<p>等到汤汁收到类似糖浆性状的时候，就关掉炉灶，把五花肉从锅子里面取出来，放在平底锅里面，稍稍翻动一下，给五花肉表面包裹一层汤汁。</p>
<p>然后，一秒钟也不要耽搁，马上开吃，看看这红烧肉的品相，它如何美味就不必多说了吧。红烧肉做好之后也会继续散发水分，瘦肉的口感会在很短的时间内变干变硬，肉皮变冷之后会变得坚韧，完全失去软糯轻盈的口感，所以吃的时候一定要抓紧时间哦！</p>
<p>再重复一下完美红烧肉需要注意几个细节：</p>
<p>1）用平底锅把五花肉表面煎成金黄色可以增加风味。</p>
<p>2）锅子的选择，一定要用锅盖密封性能好的锅子，锅底导热的均匀性也要好。</p>
<p>3）提前炒好糖色，缩短收汁时间。</p>
<p>4）收汁之前撇去里面的肥油。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/07/27/login-process-of-jwt-guard-in-laravel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/27/login-process-of-jwt-guard-in-laravel/" class="post-title-link" itemprop="url">JWTGuard的登录过程</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-27 01:24:05" itemprop="dateCreated datePublished" datetime="2017-07-27T01:24:05+08:00">2017-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 13:11:14" itemprop="dateModified" datetime="2019-11-02T13:11:14+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先配置好jwt并且使用guard，<code>config/auth.php</code> ：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'defaults'</span> =&gt; [</span><br><span class="line">    <span class="string">'guard'</span> =&gt; <span class="string">'api'</span>,</span><br><span class="line">    <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'guards'</span> =&gt; [</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="string">'api'</span> =&gt; [</span><br><span class="line">        <span class="string">'driver'</span> =&gt; <span class="string">'jwt'</span>,</span><br><span class="line">        <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">    ],</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="走流程"><a href="#走流程" class="headerlink" title="走流程"></a>走流程</h3><p><code>Auth::guard()-&gt;attempt($credential)</code><br>这个执行到了 <code>JWTGurad</code> ，代码如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">attempt</span><span class="params">(array $credentials = [], $login = true)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;lastAttempted = $user = <span class="keyword">$this</span>-&gt;provider-&gt;retrieveByCredentials($credentials);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;hasValidCredentials($user, $credentials)) &#123;</span><br><span class="line">        <span class="keyword">return</span> $login ? <span class="keyword">$this</span>-&gt;login($user) : <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行了 <code>retrieveByCredentials</code><br>再回头看看配置里面，user provider 使用的是 eloquent。<br>那么我们在 <code>EloquentUserProvider</code> 里面找到这个方法</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">retrieveByCredentials</span><span class="params">(array $credentials)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($credentials)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $query = <span class="keyword">$this</span>-&gt;createModel()-&gt;newQuery();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> ($credentials <span class="keyword">as</span> $key =&gt; $value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (! Str::contains($key, <span class="string">'password'</span>)) &#123;</span><br><span class="line">            $query-&gt;where($key, $value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $query-&gt;first();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是除了密码项，其它提供的凭据，比如用户名，邮箱，或者别的自定义凭据，全部where一下，找出一个用户。返回。<br>然后就执行到了 <code>hasValidCredentials</code> 这个方法，在 <code>JWTGuard</code> 中：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">hasValidCredentials</span><span class="params">($user, $credentials)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $user !== <span class="keyword">null</span> &amp;&amp; <span class="keyword">$this</span>-&gt;provider-&gt;validateCredentials($user, $credentials);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们还是去 <code>EloquentUserProvider</code> 里面找：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">validateCredentials</span><span class="params">(UserContract $user, array $credentials)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $plain = $credentials[<span class="string">'password'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasher-&gt;check($plain, $user-&gt;getAuthPassword());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查了一下密码是否match，match的话，登录：<code>$this-&gt;login($user)</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(JWTSubject $user)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;setUser($user);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;jwt-&gt;fromUser($user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回了一个token，也就是说，登录成功的话，返回的仅仅是一个token。</p>
<p>重点是，登录不成功的话，返回的仅仅是一个 false。</p>
<p>也就是说，使用JWTGurad登录，是没办法先检查邮箱是否存在，不存在提示，存在的话再检查密码是否符合。</p>
<p>那就只能自己写了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/07/11/about-brackets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/11/about-brackets/" class="post-title-link" itemprop="url">about-brackets</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-11 13:14:34" itemprop="dateCreated datePublished" datetime="2017-07-11T13:14:34+08:00">2017-07-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 13:16:19" itemprop="dateModified" datetime="2019-11-02T13:16:19+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Some of the following names are regional or contextual.</p>
<ul>
<li>( ) – parentheses, brackets (UK, Canada, New Zealand, South Africa and Australia), parens, round brackets, soft brackets, first brackets or circle brackets</li>
<li>[ ] – square brackets, closed brackets, hard brackets, second brackets, crotchets,[3] or brackets (US)</li>
<li>{ } – braces are “two connecting marks used in printing”; and in music “to connect staves to be performed at the same time”[4] (UK and US), French brackets, curly brackets, definite brackets, swirly brackets, curly braces, birdie brackets, Scottish brackets, squirrelly brackets, gullwings, seagulls, squiggly brackets, twirly brackets, Tuborg brackets (DK), accolades (NL), pointy brackets, third brackets, fancy brackets.</li>
<li>〈 〉– pointy brackets, angle brackets, triangular brackets, diamond brackets, tuples, or chevrons</li>
<li>&lt; &gt; – inequality signs, pointy brackets, or brackets. Sometimes referred to as angle brackets, in such cases as HTML markup. Occasionally known as broken brackets or brokets.[5]</li>
<li>⸤ ⸥; ｢ ｣ – corner brackets</li>
<li>⟦ ⟧ – double square brackets, white square brackets</li>
<li>Guillemets, ‹ › and « », are sometimes referred to as chevrons or [double] angle brackets.[1]</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/07/06/for-in-and-string-indexes-of-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/07/06/for-in-and-string-indexes-of-array/" class="post-title-link" itemprop="url">数组的“字符串”索引 & for…in 和 for…of的区别</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-07-06 01:19:39" itemprop="dateCreated datePublished" datetime="2017-07-06T01:19:39+08:00">2017-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-16 13:51:54" itemprop="dateModified" datetime="2019-11-16T13:51:54+08:00">2019-11-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一句话结论：js中的数组是没有“字符串”索引的，形如array[‘b’] = someValue只是在array对象上添加了属性。</p>
<p>Difference between for…of and for…in</p>
<p>The for…in loop will iterate over all enumerable properties of an object.</p>
<p>for in 循环会遍历一个对象上面的所有enumerable属性。</p>
<p>The for…of syntax is specific to collections, rather than all objects. It will iterate in this manner over the elements of any collection that has a [Symbol.iterator] property.</p>
<p>for of 语法是针对集合的，而不是所有的对象。它会遍历定义了[Symbol.iterator]属性的集合的所有元素。</p>
<p>The following example shows the difference between a for…of loop and a for…in loop.</p>
<p>MDN的例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, "foo", "arrCustom", "objCustom"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/06/13/scoped-slot-in-vue-2-1-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/06/13/scoped-slot-in-vue-2-1-0/" class="post-title-link" itemprop="url">理解一哈作用域插槽(Scoped slot)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-06-13 01:24:05" itemprop="dateCreated datePublished" datetime="2017-06-13T01:24:05+08:00">2017-06-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-09-28 01:27:29" itemprop="dateModified" datetime="2019-09-28T01:27:29+08:00">2019-09-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这两天在看element-ui,卡在了table组件的作用域插槽.下面来理解一下:</p>
<p>首先keep in mind, 官方文档提到作用域:<br>注意: 写在父组件里的内容在父组件内编译</p>
<p>然后我们来理解一下slot插槽:</p>
<p>是写在子组件里的<br>写父组件时,写在子组件标签里面的内容会插到这个子组件的插槽里,替换整个slot<br>综合以上两点这个大概过程就是:<br>父组件里面如果写了,首先编译会求出值来,然后再替换到子组件中.也就是这个是是父组件里面的数据.</p>
<p>正常的父子组件是啥呢, child在props里面声明它希望从father接受某个property,然后father在使用child时候给它一个property,写在标签里面,当然名字要对上.</p>
<p>这个就是vue的父子组件通信,从上到下props,从下到上是自定义event(不细说).</p>
<p>可以发现,slot其实也是从父组件传个什么鬼到子组件里面去.但是我理解一般这里只能应用样式啊,数据还是father的数据,因为是渲染完了替换掉的.需要用子组件的本地data怎么搞,还得在child里面搞.</p>
<p>那么scoped slot 提供了什么呢, father在子组件里面写一个template, 用scope=’随便一个什么名字’ 接收子组件暴露出来的数据,然后用在这个template里面.<br>下面上dummy代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--子组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;child-com&quot;&gt;</span><br><span class="line">        &lt;slot :someProperty=&quot;data&quot;&gt;</span><br><span class="line">            我是一个插槽，只是为了将父组件中包括在我这个子组件中的内容渲染进来</span><br><span class="line">        &lt;/slot&gt;    </span><br><span class="line">        &lt;slot name=&quot;namedSlot&quot;&gt;父组件中slot=&quot;namedSlot&quot;的内容才会被替换到此处&lt;/slot&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                data:&#123;message:&apos;我是child组件data里面的message&apos;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--父组件--&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;parent-com&quot;&gt;</span><br><span class="line">        &lt;child-component&gt;</span><br><span class="line">            &lt;template scope=&quot;whateverItIs&quot;&gt;</span><br><span class="line">                &lt;p class=&quot;parent-message&quot;&gt;hello from parent : &#123;&#123;fatherMessage&#125;&#125;&lt;/p&gt;</span><br><span class="line">                &lt;p class=&quot;parent-message&quot;&gt;&#123;&#123;whateverItIs.someProperty.message&#125;&#125;&lt;/p&gt;</span><br><span class="line">            &lt;/template&gt;</span><br><span class="line">            &lt;p slot=&quot;namedSlot&quot; class=&quot;parent-message&quot;&gt;我是parent中的文字,我不插无名之辈&lt;/p&gt;</span><br><span class="line">        &lt;/child-component&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    import childComponent from &apos;./child.vue&apos;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123; fatherMessage:&apos;父组件的消息&apos; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        components:&#123; childComponent &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>p.s. 这是两年前的笔记。现在回头看，就是很常用也很常见的一个设计。。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/04/18/node-api-stream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/18/node-api-stream/" class="post-title-link" itemprop="url">API学习：Stream</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-18 13:02:55" itemprop="dateCreated datePublished" datetime="2017-04-18T13:02:55+08:00">2017-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 13:03:35" itemprop="dateModified" datetime="2019-11-02T13:03:35+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>Stream是一个抽象接口，<code>stream</code>模块提供了一个基础API用来创建实现了stream接口的对象。</p>
<p>Nodejs提供了很多流对象，比如对一个HTTP服务器的request，和<code>process.stdout</code>标准输出都是流。</p>
<p>流可以使可写，可读，或者可读写的。所有的stream都是EventEmitter的实例。</p>
<p>stream模块可以这样使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Types-of-Streams"><a href="#Types-of-Streams" class="headerlink" title="Types of Streams"></a>Types of Streams</h2><ul>
<li>Readable</li>
<li>Writable</li>
<li>Duplex</li>
<li>Transform</li>
</ul>
<h2 id="Object-Mode"><a href="#Object-Mode" class="headerlink" title="Object Mode"></a>Object Mode</h2><p>Nodejs API创造的streams专门对strings和Buffer对象操作。但是对其他值操作也是可能的，这种stream在Object Mode下工作。</p>
<h2 id="Buffering"><a href="#Buffering" class="headerlink" title="Buffering"></a>Buffering</h2><p>Writable 和 Readable 流都将数据存储在一个内部缓存里，分别可用 <code>writable._writableState.getBuffer()</code> 和 <code>readable._readableState.buffer</code> 来检索到。可能缓存的数据数量由传入stream构造器的hightWaterMark来决定。对于普通stream，hightWaterMark规定了一个byte的总数，对于工作在Object Mode下的stream，它规定了一个总的object数。</p>
<p>在stream的实现调用stream.push(chunk)时，数据被缓存在Readable stream里。如果这个Stream的消费者没有调用stream.read()，这些数据就在内部队列里呆着，直到被消费为止。</p>
<p>一旦内部读取缓存的大小达到了highWaterMark规定的限值，stream会暂时停止从相关数据源读取数据，直到已缓存的数据被消费为止。（也就是说，stream会停止调用内部用来填充读取缓存的的readable._read()方法）</p>
<p>当writable.write(chunk)被重复调用时，数据被缓存在Writable stream里。当内部写缓存的总大小低于highWaterMark规定的限值时，writable.write()的调用会返回true，一旦达到或者超过限值，就会返回false。<br>stream API特别是stream.pipe()方法的一个重要目标，就是把数据的缓存限制在一个可接受的程度，这样速度不同的数据源和数据目的地就可以在一个有限的内存下正常工作(而不会撑满内存导致溢出)。<br>因 为<code>Duplex</code> 和 <code>Transform streams</code> 都是可读写的，他们都有两个独立的内部缓存用来读和写，允许两边独立操作，同时保持一个合适有效的数据流。比如，net.Socket实例是Duplex stream，它的Readable 一侧允许消费从socket里接收到的数据，Writable一侧允许向socket内写入数据。因为读写数据的速度有可能不一样，两边分开独立（缓存和）操作就很重要。<br><em>说实话这里没看懂</em></p>
<h2 id="给Stream-Consumers的API"><a href="#给Stream-Consumers的API" class="headerlink" title="给Stream Consumers的API"></a>给Stream Consumers的API</h2><p>不管多简单，基本上所有的Node.js程序都在以某种方式使用stream。下面是一个在实现一个HTTP服务器的程序中使用stream的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.createServer( <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// req is an http.IncomingMessage, which is a Readable Stream</span></span><br><span class="line">  <span class="comment">// res is an http.ServerResponse, which is a Writable Stream</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> body = <span class="string">''</span>;</span><br><span class="line">  <span class="comment">// Get the data as utf8 strings.</span></span><br><span class="line">  <span class="comment">// If an encoding is not set, Buffer objects will be received.</span></span><br><span class="line">  req.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Readable streams emit 'data' events once a listener is added</span></span><br><span class="line">  req.on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    body += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// the end event indicates that the entire body has been received</span></span><br><span class="line">  req.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(body);</span><br><span class="line">      <span class="comment">// write back something interesting to the user:</span></span><br><span class="line">      res.write(<span class="keyword">typeof</span> data);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (er) &#123;</span><br><span class="line">      <span class="comment">// uh oh!  bad json!</span></span><br><span class="line">      res.statusCode = <span class="number">400</span>;</span><br><span class="line">      <span class="keyword">return</span> res.end(<span class="string">`error: <span class="subst">$&#123;er.message&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">1337</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// $ curl localhost:1337 -d '&#123;&#125;'</span></span><br><span class="line"><span class="comment">// object</span></span><br><span class="line"><span class="comment">// $ curl localhost:1337 -d '"foo"'</span></span><br><span class="line"><span class="comment">// string</span></span><br><span class="line"><span class="comment">// $ curl localhost:1337 -d 'not json'</span></span><br><span class="line"><span class="comment">// error: Unexpected token o</span></span><br></pre></td></tr></table></figure>

<p>可写流暴露了如write()和end()的方法，用来向stream写入数据。<br>可读流使用EventEmitter API来通知程序啥时候数据可以从stream中读取了。有多种方式可以读取。<br>可读流和可写流都各种使用EventEmitter API，来和stream的当前状态通信。</p>
<h2 id="Writable-Streams"><a href="#Writable-Streams" class="headerlink" title="Writable Streams"></a>Writable Streams</h2><p>Writable Streams是一个数据要写入的目的地的抽象。</p>
<ul>
<li>HTTP requests, on the client</li>
<li>HTTP responses, on the server</li>
<li>fs write streams</li>
<li>zlib streams</li>
<li>crypto streams</li>
<li>TCP sockets</li>
<li>child process stdin</li>
<li>process.stdout, process.stderr</li>
</ul>
<p>所有的Writable streams都实现了由 <code>stream.Writable</code> 类定义的接口。<br>虽然各种实例各有不同，但他们都遵循同样的基本使用模式，如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myStream = getWritableStreamSomehow();</span><br><span class="line">myStream.write(<span class="string">'some data'</span>);</span><br><span class="line">myStream.write(<span class="string">'some more data'</span>);</span><br><span class="line">myStream.end(<span class="string">'done writing data'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Class-stream-Writable"><a href="#Class-stream-Writable" class="headerlink" title="Class: stream.Writable"></a>Class: stream.Writable</h3><h4 id="Event-‘close’"><a href="#Event-‘close’" class="headerlink" title="Event: ‘close’"></a>Event: ‘close’</h4><h4 id="Event-‘drain’"><a href="#Event-‘drain’" class="headerlink" title="Event: ‘drain’"></a>Event: ‘drain’</h4><h4 id="Event-‘error’"><a href="#Event-‘error’" class="headerlink" title="Event: ‘error’"></a>Event: ‘error’</h4><h4 id="Event-‘finish’"><a href="#Event-‘finish’" class="headerlink" title="Event: ‘finish’"></a>Event: ‘finish’</h4><h4 id="Event-‘pipe’"><a href="#Event-‘pipe’" class="headerlink" title="Event: ‘pipe’"></a>Event: ‘pipe’</h4><h4 id="Event-‘unpipe’"><a href="#Event-‘unpipe’" class="headerlink" title="Event: ‘unpipe’"></a>Event: ‘unpipe’</h4><h4 id="writable-cork"><a href="#writable-cork" class="headerlink" title="writable.cork()"></a>writable.cork()</h4><h4 id="writable-end-chunk-encoding-callback"><a href="#writable-end-chunk-encoding-callback" class="headerlink" title="writable.end([chunk][, encoding][, callback])"></a>writable.end([chunk][, encoding][, callback])</h4><h4 id="writable-setDefaultEncoding-encoding"><a href="#writable-setDefaultEncoding-encoding" class="headerlink" title="writable.setDefaultEncoding(encoding)"></a>writable.setDefaultEncoding(encoding)</h4><h4 id="writable-uncork"><a href="#writable-uncork" class="headerlink" title="writable.uncork()"></a>writable.uncork()</h4><h4 id="writable-write-chunk-encoding-callback"><a href="#writable-write-chunk-encoding-callback" class="headerlink" title="writable.write(chunk[, encoding][, callback])"></a>writable.write(chunk[, encoding][, callback])</h4><h2 id="Readable-Streams"><a href="#Readable-Streams" class="headerlink" title="Readable Streams"></a>Readable Streams</h2><p>Writable Streams是一个源的抽象，数据可以通过它来消费。</p>
<ul>
<li>HTTP responses, on the client</li>
<li>HTTP requests, on the server</li>
<li>fs read streams</li>
<li>zlib streams</li>
<li>crypto streams</li>
<li>TCP sockets</li>
<li>child process stdout and stderr</li>
<li>process.stdin</li>
</ul>
<p>所有的Readable streams都实现了由 <code>stream.Readable</code> 类定义的接口。</p>
<h3 id="Two-Modes-两种模式"><a href="#Two-Modes-两种模式" class="headerlink" title="Two Modes 两种模式"></a>Two Modes 两种模式</h3><p>Readable streams实际上运行在以下两种模式之一：flowing和paused</p>
<p>在flowing模式下，数据从相关系统中自动读取，并通过EventEmitter接口使用事件尽可能快的提供给一个程序。</p>
<p>在paused模式下，stream.rad()方法必须显式的调用，来从stream中读取数据块。</p>
<p>所有的Readable streams开始都处在paused模式，并可以通过以下几种方式之一切换成flowing模式：</p>
<ul>
<li>添加一个’data’事件的handler</li>
<li>调用stream.resume()方法</li>
<li>调用stream.pipe()方法，来将数据传给一个Writable</li>
</ul>
<p>Readable可以通过以下几种方式之一切换回paused模式：</p>
<ul>
<li>如果没有pipe目的地，调用stream.pause()方法</li>
<li>如果有pipe目的地，移除所有的’data’事件handler，并通过调用stream.unpipe()移除所有的pipe目的地。</li>
</ul>
<p>需要记住的是，一个Readable不会生成数据，直到一个或者消费数据或者忽略数据的机制被提供。一旦消费机制消失或者失效，Readable会尝试停止生成数据</p>
<h3 id="Three-States-三种状态"><a href="#Three-States-三种状态" class="headerlink" title="Three States 三种状态"></a>Three States 三种状态</h3><p>Readable“两种操作模式”是一个对其实现中更复杂的内部状态管理的简化抽象。<br>明确的说，任何给定的时点，一个Readable会处在以下三种可能状态之一：</p>
<ul>
<li>readable._readableState.flowing = null</li>
<li>readable._readableState.flowing = false</li>
<li>readable._readableState.flowing = true<br>null：消费数据的机制没有提供，所以stream不会生成他的数据<br>给’data’事件添加一个监听器，调用readable.pipe()方法，或者调用readable.resume()方法会把flowing属性置为true，导致Readable开始积极地emit事件，同时数据开始生成。<br>调用readable.pause()，readable.unpipe()或者接受到‘back pressure’会让flowing属性被置为false，暂停事件流，但不会停止数据的生成。<br>当flowing是false时，数据可能在stream的内部缓存里积累。<h3 id="Chosse-One-挑一个"><a href="#Chosse-One-挑一个" class="headerlink" title="Chosse One 挑一个"></a>Chosse One 挑一个</h3>Readable stream API 随着Node.js版本在进化，提供了一堆消费数据的方法。通常应该只选择一个来消费数据，永远不要用多种方式来消费同一个stream中的数据。<br>一般推荐readable.pipe()，因为使用最简单。需要细粒度的控制数据传输和生成的可以使用EventEmitter和readable.pause()/readable.resume() API。</li>
</ul>
<h3 id="Class-stream-Readable"><a href="#Class-stream-Readable" class="headerlink" title="Class: stream.Readable"></a>Class: stream.Readable</h3><h4 id="Event-‘close’-1"><a href="#Event-‘close’-1" class="headerlink" title="Event: ‘close’"></a>Event: ‘close’</h4><h4 id="Event-‘data’"><a href="#Event-‘data’" class="headerlink" title="Event: ‘data’"></a>Event: ‘data’</h4><h4 id="Event-‘end’"><a href="#Event-‘end’" class="headerlink" title="Event: ‘end’"></a>Event: ‘end’</h4><h4 id="Event-‘error’-1"><a href="#Event-‘error’-1" class="headerlink" title="Event: ‘error’"></a>Event: ‘error’</h4><h4 id="Event-‘readable’"><a href="#Event-‘readable’" class="headerlink" title="Event: ‘readable’"></a>Event: ‘readable’</h4><h4 id="readable-isPaused"><a href="#readable-isPaused" class="headerlink" title="readable.isPaused()"></a>readable.isPaused()</h4><h4 id="readable-pause"><a href="#readable-pause" class="headerlink" title="readable.pause()"></a>readable.pause()</h4><h4 id="readable-pipe-destination-options"><a href="#readable-pipe-destination-options" class="headerlink" title="readable.pipe(destination[, options])"></a>readable.pipe(destination[, options])</h4><h4 id="readable-read-size"><a href="#readable-read-size" class="headerlink" title="readable.read([size])"></a>readable.read([size])</h4><h4 id="readable-resume"><a href="#readable-resume" class="headerlink" title="readable.resume()"></a>readable.resume()</h4><h4 id="readable-setEncoding-encoding"><a href="#readable-setEncoding-encoding" class="headerlink" title="readable.setEncoding(encoding)"></a>readable.setEncoding(encoding)</h4><h4 id="readable-unpipe-destination"><a href="#readable-unpipe-destination" class="headerlink" title="readable.unpipe([destination])"></a>readable.unpipe([destination])</h4><h4 id="readable-unshift-chunk"><a href="#readable-unshift-chunk" class="headerlink" title="readable.unshift(chunk)"></a>readable.unshift(chunk)</h4><h4 id="readable-wrap-stream"><a href="#readable-wrap-stream" class="headerlink" title="readable.wrap(stream)"></a>readable.wrap(stream)</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://twohappy.me/2017/04/18/node-api-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="twohappy">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="兽人永不为奴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2017/04/18/node-api-events/" class="post-title-link" itemprop="url">API学习：Stream</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2017-04-18 13:02:55" itemprop="dateCreated datePublished" datetime="2017-04-18T13:02:55+08:00">2017-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-11-02 13:04:29" itemprop="dateModified" datetime="2019-11-02T13:04:29+08:00">2019-11-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h1><p>大部分Nodejs核心API建立在一个异步事件驱动的架构上，emitters周期性的触发事件，导致函数对象listeners调用执行。</p>
<p>比如，每次一个peer连接到net.Server对象时，它就触发一个事件，；当文件打开时，fs.ReadStream就触发一个事件；当数据可以被读取时，stream就触发一个事件。</p>
<p>所有会触发事件的对象都是EventEmitter类的实例。这些对象暴露出eventEmitter.on()方法，允许一个或者多个函数监听该对象触发的事件。通常，事件名是驼峰字符串，但是任何符合JS规范的属性名都可以用。</p>
<p>当EventEmitter对象触发一个事件，所有监听这个特定事件的函数会被<strong>同步调用</strong>。被调用方法返回的所有值都会被<strong>忽略并丢弃</strong>。<br>下面是个简单的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEmitter</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'an event occurred!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="向监听者传递参数和this"><a href="#向监听者传递参数和this" class="headerlink" title="向监听者传递参数和this"></a>向监听者传递参数和this</h2><p>eventEmitter.emit()方法允许把任意参数传给监听函数。划重点：普通函数被EventEmitter调用时候啊，this被置为listener attached的那个触发器。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// Prints:</span></span><br><span class="line">  <span class="comment">//   a b MyEmitter &#123;</span></span><br><span class="line">  <span class="comment">//     domain: null,</span></span><br><span class="line">  <span class="comment">//     _events: &#123; event: [Function] &#125;,</span></span><br><span class="line">  <span class="comment">//     _eventsCount: 1,</span></span><br><span class="line">  <span class="comment">//     _maxListeners: undefined &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>然而回调函数用箭头函数时候，this就不再指向那个触发器实例了。。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, (a, b) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, <span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">// Prints: a b &#123;&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>//todo:这里指向了个啥？</p>
<h2 id="同步-vs-异步"><a href="#同步-vs-异步" class="headerlink" title="同步 vs 异步"></a>同步 vs 异步</h2><p>EventListener 按照注册顺序，同步调用所有的监听函数，这样可以保证正确的事件顺序，避免竞争执行和逻辑错误;需要时，监听函数可以使用setImmediate()和process.nextTick()切换成异步执行:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, (a, b) =&gt; &#123;</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this happens asynchronously'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="只处理一次事件"><a href="#只处理一次事件" class="headerlink" title="只处理一次事件"></a>只处理一次事件</h2><p>当使用eventEmitter.on()注册了一个监听器后，每次它所监听的事件被触发，这个监听器就会被调用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"><span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints: 1</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints: 2</span></span><br></pre></td></tr></table></figure>

<p>而使用eventEmitter.once()方法，就可以注册一个只调用一次的监听器函数。当事件触发后，这个监听器先被注销然后再执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"><span class="keyword">let</span> m = <span class="number">0</span>;</span><br><span class="line">myEmitter.once(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints: 1</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Ignored</span></span><br></pre></td></tr></table></figure>

<h2 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h2><p>当一个EventEmitter实例中有错误发生，标准处理是触发一个‘error’事件。他们在node中当做特殊案例来处理。<br>如果一个EventEmitter连一个注册在error事件下的监听器都没有，而’error’事件触发了，这个错误会被抛出，栈追踪打印，Node.js进程退出。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'whoops!'</span>));</span><br><span class="line"><span class="comment">// Throws and crashes Node.js</span></span><br></pre></td></tr></table></figure>

<p>为了让Node.js进程不至于崩溃，可以在process对象的uncaughtException事件下面注册一个监听器（或者可以使用domain模块，这个模块已经不建议使用）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"></span><br><span class="line">process.on(<span class="string">'uncaughtException'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'whoops! there was an error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myEmitter.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'whoops!'</span>));</span><br><span class="line"><span class="comment">// Prints: whoops! there was an error</span></span><br></pre></td></tr></table></figure>

<p>坠吼还是总给’error’事件注册上监听器</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line">myEmitter.on(<span class="string">'error'</span>, (err) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'whoops! there was an error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'error'</span>, <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'whoops!'</span>));</span><br><span class="line"><span class="comment">// Prints: whoops! there was an error</span></span><br></pre></td></tr></table></figure>

<h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a><code>EventEmitter</code> 类</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br></pre></td></tr></table></figure>

<p>所有的<code>EventEmitter</code>在新监听器添加和移除的时候都会相应的触发 <code>newListener</code> 和 <code>removeListener</code> 事件</p>
<h3 id="newListener-事件"><a href="#newListener-事件" class="headerlink" title="newListener 事件"></a><code>newListener</code> 事件</h3><ul>
<li>eventName 新添加的事件名</li>
<li>listener 事件处理程序<br>EventEmitter实例在一个监听器添加到其内部监听器数组<strong>之前</strong>会触发一个它自己的 <code>newListener</code> 事件。<br>因为这个事件是在添加listener（我们假设这个回调函数叫A）之前触发的，所以有（划重点）：如果在newListener回调函数中，有额外的注册在同一个事件name下的listener（我们假设这个回调函数叫B）被注册，这个listener（B）会被插入在上面提到的那个listener（B）之前。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"><span class="comment">// Only do this once so we don't loop forever</span></span><br><span class="line">myEmitter.once(<span class="string">'newListener'</span>, (event, listener) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (event === <span class="string">'event'</span>) &#123;</span><br><span class="line">    <span class="comment">// Insert a new listener in front</span></span><br><span class="line">    myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints:</span></span><br><span class="line"><span class="comment">//   B</span></span><br><span class="line"><span class="comment">//   A</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="removeListener-事件"><a href="#removeListener-事件" class="headerlink" title="removeListener 事件"></a><code>removeListener</code> 事件</h3><ul>
<li>eventName 新添加的事件名</li>
<li>listener 事件处理程序<br>这个事件在<code>listener</code>移除之后触发。</li>
</ul>
<h3 id="EventEmitter-defaultMaxListeners-属性"><a href="#EventEmitter-defaultMaxListeners-属性" class="headerlink" title="EventEmitter.defaultMaxListeners 属性"></a>EventEmitter.defaultMaxListeners 属性</h3><p>默认来讲，单个事件可以注册最大10个监听器。用emitter.setMaxListeners(n) 可以为个别的EventEmitter实例改变这个上限。如果要改变所有实例的上限，可以用EventEmitter.defaultMaxListerners属性</p>
<p>这个属性影响所有的（包括在改变操作之前创建的）EventEmiiter实例。但是，调用emitter.setMaxListeners(n)比EventEmitter.defaultMaxListeners优先生效。</p>
<p>然后这个不是硬性龟腚。EventEmitter实例允许添加超出最大值的listener，只是会输出一个警告，检测到 “possible EventEmitter memory leak” 。对单个的EventEmitter，可以用emitter.getMaxListeners()和emitter.setMaxListeners() 方法来临时避免这个警告：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emitter.setMaxListeners(emitter.getMaxListeners() + <span class="number">1</span>);</span><br><span class="line">emitter.once(<span class="string">'event'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// do stuff</span></span><br><span class="line">  emitter.setMaxListeners(<span class="built_in">Math</span>.max(emitter.getMaxListeners() - <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>多个的话就多加几个吧。。</p>
<p>–trace-warnings 这个命令行参数可以用来显示这种warning</p>
<p>触发的warning可以用process.on(‘warning’)来查看，还有额外的emitter,type和count属性，各自指向事件触发器实例，事件名称和添加的事件数量。这个warning的name属性是’MaxListenersExceededWarning’。</p>
<h3 id="emitter-addListener-eventName-listener"><a href="#emitter-addListener-eventName-listener" class="headerlink" title="emitter.addListener(eventName,listener)"></a>emitter.addListener(eventName,listener)</h3><p>等于emitter.on(eventName,listener)</p>
<h3 id="emitter-emit-eventName-…args"><a href="#emitter-emit-eventName-…args" class="headerlink" title="emitter.emit(eventName[, …args])"></a>emitter.emit(eventName[, …args])</h3><p>按照注册的先后顺序，依次同步调用监听函数，给他们传入这里提供的参数。<br>如果emit的事件有监听函数，返回一个true，否则false</p>
<h3 id="emitter-eventNames"><a href="#emitter-eventNames" class="headerlink" title="emitter.eventNames()"></a>emitter.eventNames()</h3><p>返回一个这个触发器上面注册监听器的事件们构成的数组，值是String或者Symbol。<br>注意这是个方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> myEE = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEE.on(<span class="string">'foo'</span>, () =&gt; &#123;&#125;);</span><br><span class="line">myEE.on(<span class="string">'bar'</span>, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(<span class="string">'symbol'</span>);</span><br><span class="line">myEE.on(sym, () =&gt; &#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myEE.eventNames());</span><br><span class="line"><span class="comment">// Prints: [ 'foo', 'bar', Symbol(symbol) ]</span></span><br></pre></td></tr></table></figure>

<h3 id="emitter-getMaxListeners"><a href="#emitter-getMaxListeners" class="headerlink" title="emitter.getMaxListeners()"></a>emitter.getMaxListeners()</h3><p>返回当前最大监听数：<br>emitter.setMaxListeners(n)设置的，或者由EventEmitter.defaultMaxListeners默认的.</p>
<h3 id="emitter-listenerCount-eventName"><a href="#emitter-listenerCount-eventName" class="headerlink" title="emitter.listenerCount(eventName)"></a>emitter.listenerCount(eventName)</h3><p>监听某个事件的监听器个数</p>
<h3 id="emitter-listeners-eventName"><a href="#emitter-listeners-eventName" class="headerlink" title="emitter.listeners(eventName)"></a>emitter.listeners(eventName)</h3><p>返回一个监听eventName的监听器数组的副本，（里面应该是一堆listener函数）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'connection'</span>, (stream) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(util.inspect(server.listeners(<span class="string">'connection'</span>)));</span><br><span class="line"><span class="comment">// Prints: [ [Function] ]</span></span><br></pre></td></tr></table></figure>

<h3 id="emitter-on-eventName-listener"><a href="#emitter-on-eventName-listener" class="headerlink" title="emitter.on(eventName, listener)"></a>emitter.on(eventName, listener)</h3><p>把listen函数加到监听’eventName’的监听器数组尾部，这里不会检查这个函数是否已经被添加过了，多次传入同样事件名和监听器组合的emitter.on的调用，结果将是listener被添加和调用多次。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.on(<span class="string">'connection'</span>, (stream) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>它返回一个指向EventEmitter的reference，这就可以链式调用.测试的时候发现理解不了调用的执行顺序,如果有Symbol的话。。。<br>事件监听默认是顺序执行的，按照添加的先后顺序，emitter.prependListener()方法可以把监听器插入到监听器队列的开头</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEE = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">myEE.on(<span class="string">'foo'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'a'</span>));</span><br><span class="line">myEE.prependListener(<span class="string">'foo'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'b'</span>));</span><br><span class="line">myEE.emit(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">// Prints:</span></span><br><span class="line"><span class="comment">//   b</span></span><br><span class="line"><span class="comment">//   a</span></span><br></pre></td></tr></table></figure>

<h3 id="emitter-once-eventName-listener"><a href="#emitter-once-eventName-listener" class="headerlink" title="emitter.once(eventName, listener)"></a>emitter.once(eventName, listener)</h3><p>emitter.on的一次性版本，当事件触发的时候先移除再调用callback。同样返回一个EventEmitter实例方便链式调用。<br>同样有一个插入到数组队列首部的方法emitter.prependOnceListener() </p>
<h3 id="emitter-prependListener-eventName-listener"><a href="#emitter-prependListener-eventName-listener" class="headerlink" title="emitter.prependListener(eventName, listener)"></a>emitter.prependListener(eventName, listener)</h3><h3 id="emitter-prependOnceListener-eventName-listener"><a href="#emitter-prependOnceListener-eventName-listener" class="headerlink" title="emitter.prependOnceListener(eventName, listener)"></a>emitter.prependOnceListener(eventName, listener)</h3><h3 id="emitter-removeAllListeners-eventName"><a href="#emitter-removeAllListeners-eventName" class="headerlink" title="emitter.removeAllListeners([eventName])"></a>emitter.removeAllListeners([eventName])</h3><p>不传参数就移除所有监听器，传就移除对应事件的监听器。<br>移除在代码的其他地方添加的监听器是一个bad practice，尤其是当EventEmitter实例是由其他组件或者模块创建的时候。<br>同样返回一个EventEmitter的指向，链式调用。</p>
<h3 id="emitter-removeListener-eventName-listener"><a href="#emitter-removeListener-eventName-listener" class="headerlink" title="emitter.removeListener(eventName, listener)"></a>emitter.removeListener(eventName, listener)</h3><p>移除eventName事件下的特定监听函数listener，一次只能移除一个，如果同一个listener添加了多次，必须移除多次</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里应该有个引用</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'someone connected!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">server.on(<span class="string">'connection'</span>, callback);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">server.removeListener(<span class="string">'connection'</span>, callback);</span><br></pre></td></tr></table></figure>

<p>注意，一旦一个事件被触发，所有在它之上的监听器会被依次调用（在emitting之时）。这意味着任何在emitting之后，最后一个监听器执行完之前执行的removeListener()或者removeAllListeners()调用，将不会把listeners从进行中的emit()移除，在顺序执行结束后，行为就跟预期一样了（移除了）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEmitter = <span class="keyword">new</span> MyEmitter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbackA = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>);</span><br><span class="line">  myEmitter.removeListener(<span class="string">'event'</span>, callbackB);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbackB = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, callbackA);</span><br><span class="line"></span><br><span class="line">myEmitter.on(<span class="string">'event'</span>, callbackB);</span><br><span class="line"></span><br><span class="line"><span class="comment">// callbackA removes listener callbackB but it will still be called.</span></span><br><span class="line"><span class="comment">// Internal listener array at time of emit [callbackA, callbackB]</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints:</span></span><br><span class="line"><span class="comment">//   A</span></span><br><span class="line"><span class="comment">//   B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// callbackB is now removed.</span></span><br><span class="line"><span class="comment">// Internal listener array [callbackA]</span></span><br><span class="line">myEmitter.emit(<span class="string">'event'</span>);</span><br><span class="line"><span class="comment">// Prints:</span></span><br><span class="line"><span class="comment">//   A</span></span><br></pre></td></tr></table></figure>

<p>监听器们是有一个内部的数组来管理的，调用这个方法会改变被移除的listener之后的一堆listener的位置索引。这不会引起调用顺序的变化，但意味着内部监听方法队列的拷贝们，比如像emitter.listeners()方法返回的数组就都需要重建一次。（它们还是之前的拷贝）。<br>仍然返回一个EventEmitter的指向，方便链式调用</p>
<h3 id="emitter-setMaxListeners-n"><a href="#emitter-setMaxListeners-n" class="headerlink" title="emitter.setMaxListeners(n)"></a>emitter.setMaxListeners(n)</h3><p>默认的EventEmitter会在某一个事件被添加了超过10个监听函数时，打印一个warning，这个对查找内存泄漏很有帮助。但是显然不是所有的事件都应该被限制到10个，这个方法可以对具体实例设置它的上限，Infinity（或者0？？）表示无上限</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="twohappy"
    src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">twohappy</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">twohappy</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.9.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
